use crate::{
    Codec, Size,
    fields::{FieldElement, FieldId, SerializedFieldElement},
};
use anyhow::{Context, anyhow};
use educe::Educe;
use std::{
    collections::HashSet,
    fmt::{self, Formatter},
    io::{Cursor, Read},
};

/// A circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, PartialEq, Eq, Educe)]
#[educe(Debug)]
pub struct Circuit {
    /// 1 byte version. Currently always 1.
    pub(crate) version: u8,
    /// The field this circuit uses. (not clear what subfield is used; hard coded to P256?)
    pub(crate) field: FieldId,
    /// Number of output wires (also `nv` in some places).
    pub(crate) num_outputs: Size,
    /// Number of copies (what's a copy? is this used?)
    pub(crate) num_copies: Size,
    /// Number of public inputs.
    pub(crate) num_public_inputs: Size,
    /// Least input wire not known to be in the subfield (what's the subfield though?)
    pub(crate) subfield_boundary: Size,
    /// Number of inputs, including witnesses. Always >= num_public_inputs, which is the index of
    /// of the first private input.
    pub(crate) num_inputs: Size,
    /// Number of layers in the circuit.
    pub(crate) num_layers: Size,
    /// Array of constants pointed to by the circuit's quads. Encoded as a variable length array of
    /// [`SerializedFieldElement`], which can then be decoded into a particular [`FieldElement`]
    /// implementation based on the value of `field`.
    pub(crate) constant_table: Vec<SerializedFieldElement>,
    /// The layers of the circuit. There are num_layers of these, so this gets serialized as a fixed
    /// length array.
    pub(crate) layers: Vec<CircuitLayer>,
    /// 32 byte identifier for the circuit. Generated by the circuit compiler.
    #[educe(Debug(method(fmt_id)))]
    pub(crate) id: [u8; 32],
}

fn fmt_id(s: &[u8; 32], f: &mut Formatter<'_>) -> fmt::Result {
    f.write_str(hex::encode(s).as_str())
}

impl Codec for Circuit {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let version = u8::decode(bytes)?;
        let field = FieldId::decode(bytes)?;
        let num_outputs = Size::decode(bytes)?;
        let num_copies = Size::decode(bytes)?;
        let num_public_inputs = Size::decode(bytes)?;
        let subfield_boundary = Size::decode(bytes)?;
        let num_inputs = Size::decode(bytes)?;
        let num_layers = Size::decode(bytes)?;
        let num_constants = Size::decode(bytes)?;

        // Decode constant table: first a count of elements, then each element's length is obtained
        // from the field ID.
        let mut constant_table = Vec::with_capacity(usize::from(num_constants));
        for _ in 0..num_constants.into() {
            constant_table.push(SerializedFieldElement::decode(field, bytes)?);
        }

        let layers = CircuitLayer::decode_fixed_array(bytes, num_layers.into())
            .context("failed to decode layers")?;
        let mut id = [0u8; 32];
        bytes
            .read_exact(&mut id)
            .context("failed to read 32 bytes of circuit ID")?;

        Ok(Self {
            version,
            field,
            num_outputs,
            num_copies,
            num_public_inputs,
            subfield_boundary,
            num_inputs,
            num_layers,
            constant_table,
            layers,
            id,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.version.encode(bytes)?;
        self.field.encode(bytes)?;
        self.num_outputs.encode(bytes)?;
        self.num_copies.encode(bytes)?;
        self.num_public_inputs.encode(bytes)?;
        self.subfield_boundary.encode(bytes)?;
        self.num_inputs.encode(bytes)?;
        self.num_layers.encode(bytes)?;

        // Encode constant table: first a count of elements, then each element's length is obtained
        // from the field ID.
        Size::from(self.constant_table.len() as u32).encode(bytes)?;
        for constant in &self.constant_table {
            constant.encode(bytes)?;
        }

        if usize::from(self.num_layers) != self.layers.len() {
            return Err(anyhow!("num_layers does not match length of layers array"));
        }
        CircuitLayer::encode_fixed_array(&self.layers, bytes)?;
        bytes.extend_from_slice(&self.id);

        Ok(())
    }
}

impl Circuit {
    /// Retrieve the requested constant from the circuit's constant table, if it exists.
    pub fn constant<F: FieldElement>(&self, index: Size) -> Result<F, anyhow::Error> {
        F::try_from(
            &self
                .constant_table
                .get(usize::from(index))
                .ok_or_else(|| anyhow!("index {} not present in constant table", index))?
                .clone()
                .0,
        )
    }

    /// Evaluate the circuit with the provided inputs.
    ///
    /// Bugs: taking inputs as u128 is inadequate for larger fields like P256.
    pub fn evaluate<FE: FieldElement>(
        &self,
        inputs: &[u128],
    ) -> Result<Evaluation<FE>, anyhow::Error> {
        let inputs: Vec<_> = inputs.iter().map(|input| FE::from_u128(*input)).collect();
        // There are n layers of gates, but with the inputs, we have n + 1 layers of wires.
        let mut wires = Vec::with_capacity(self.layers.len() + 1);

        // "By convention, the input wire Vj[0] = 1 for all layers, and thus the quad representation
        // handles the classic add and multiplication gates in a uniform manner."
        // This is because we represent constants in the circuit by multiplying the input 1 by
        // whatever the value we need. We apply this fixup only for the first layer, as subsequent
        // layers are constructed to propagate the constant 1.
        //
        // https://eprint.iacr.org/2024/2010.pdf, section 2.1
        wires.push([&[FE::ONE], inputs.as_slice()].concat());

        // We are iterating over layers in reverse, so the output layer is at the end of the
        // iterator
        let output_layer_index = usize::from(self.num_layers) - 1;
        for (layer_index, layer) in self
            .layers
            .iter()
            // In the serialized format, the input layer comes last, so reverse the layers iterator.
            .rev()
            .enumerate()
        {
            let next_layer_num_wires = if layer_index == output_layer_index {
                self.num_outputs
            } else {
                self.layers[
                    // index from the end because we are iterating self.layers in reverse
                    output_layer_index - layer_index
                    // next layer of the circuit is -1
                    - 1
                ]
                .num_wires
            };
            // A single gate may receive contributions from multiple quads, so preallocate a vector
            // of length matching the next layer's number of input wires, and accumulate quad
            // outputs into that.
            // Depending on the circuit compiler, it's possible that there will be unused elements
            // in this vector.
            let mut gate_outputs = vec![FE::ZERO; next_layer_num_wires.into()];

            // Note which gates receive contributions from Z quads.
            let mut z_gate_indexes = HashSet::new();

            for (quad_index, quad) in layer.quads.iter().enumerate() {
                // Evaluate this quad: look up its value in the constants table, then multiply that
                // by the value of the input wires.
                let quad_value: FE = self.constant(quad.const_table_index).context(format!(
                    "constant missing in quad {quad_index} on layer {layer_index}"
                ))?;

                let left_wire = wires[layer_index]
                    .get(usize::from(quad.left_wire_index))
                    .ok_or_else(|| {
                        anyhow!(
                            "quad {quad_index} on layer {layer_index} contains left wire index {} \
                            not present in previous layer of circuit {:?}",
                            quad.left_wire_index,
                            wires[layer_index],
                        )
                    })?;
                let right_wire = wires[layer_index]
                    .get(usize::from(quad.right_wire_index))
                    .ok_or_else(|| {
                        anyhow!(
                            "quad {quad_index} on layer {layer_index} contains right wire index {} \
                            not present in previous layer of circuit {:?}",
                            quad.right_wire_index,
                            wires[layer_index],
                        )
                    })?;

                let quad_output = if quad_value.is_zero().into() {
                    z_gate_indexes.insert(usize::from(quad.gate_index));

                    *left_wire * right_wire
                } else {
                    quad_value * left_wire * right_wire
                };

                // Specification interpretation verification: this should never happen. We check
                // this condition in roundtrip_circuit_test_vector, but not in deserialization.
                if quad.gate_index >= next_layer_num_wires {
                    panic!(
                        "quad {quad_index} on layer {layer_index} contains gate index {} exceeding \
                        the next layer's number of input wires {next_layer_num_wires}",
                        quad.gate_index,
                    )
                }
                gate_outputs[usize::from(quad.gate_index)] += quad_output;
            }

            // Specification interpretation verification: check that gates which received input from
            // Z quads output zero. This has to be true since (1) all Z quads output zero and (2) we
            // expect that Q and Z are disjoint. We verify the latter in
            // roundtrip_circuit_test_vector.
            for gate_index in z_gate_indexes {
                assert!(bool::from(gate_outputs[gate_index].is_zero()));
            }

            wires.push(gate_outputs);
        }

        // Reverse wires so that the inputs come last and the outputs come first.
        wires.reverse();
        Ok(Evaluation { wires })
    }
}

/// The evaluation of a circuit.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Evaluation<FieldElement> {
    /// The value of each of the wires of the circuit after evaluation. An n-layer circuit has n+1
    /// layers of wire values. Layer index 0 is the outputs and layer index n is the inputs. The
    /// length of each layer depends on the number of gates on each layer.
    wires: Vec<Vec<FieldElement>>,
}

impl<FieldElement> Evaluation<FieldElement> {
    pub fn outputs(&self) -> &[FieldElement] {
        self.wires[0].as_slice()
    }
}

/// A layer of a circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, Educe, PartialEq, Eq)]
#[educe(Debug)]
pub struct CircuitLayer {
    /// This is the number of bits needed to name a wire on this layer ([1]). Thus, it's usually
    /// `ceil(log_2(num_wires))`, but apparently not always. The value of output wire i is 0 for
    /// `i >= 2^logw`, because there are no such wires at this layer.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.2
    ///
    /// Longfellow calls this "number of binding rounds for the hand variables".
    pub(crate) logw: Size,
    /// Number of wires/inputs to the layer.
    pub(crate) num_wires: Size,
    /// Quads describing this layer of the circuit. A variable length array.
    ///
    /// [5.3.3.][1] discusses the combined circuit QZ = Q + beta * Z for some random beta. beta is
    /// chosen during proof generation, and so is not serialized. However the combined quad does
    /// impact the serialization format: because Q and Z are disjoint matrices, then any quad whose
    /// value is nonzero is understood to be part of Q, and any quad whose value is zero is
    /// understood to be part of Z.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    pub(crate) quads: Vec<Quad>,
}

impl Codec for CircuitLayer {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let logw = Size::decode(bytes)?;
        let num_wires = Size::decode(bytes)?;
        let num_quads = Size::decode(bytes)?;

        let mut prev_quad = None;
        let mut quads = Vec::with_capacity(num_quads.into());
        for _ in 0..num_quads.0 {
            let quad = Quad::decode(prev_quad, bytes)?;
            prev_quad = Some(quad);
            quads.push(quad);
        }

        Ok(Self {
            logw,
            num_wires,
            quads,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.logw.encode(bytes)?;
        self.num_wires.encode(bytes)?;
        Size::from(self.quads.len() as u32).encode(bytes)?;

        let mut prev_quad = None;
        for quad in &self.quads {
            quad.encode(prev_quad, bytes)?;
            prev_quad = Some(*quad);
        }

        Ok(())
    }
}

/// A quad describes an individual gate in the circuit, serialized according to struct Quad in [1]
/// and the ad-hoc definition in [2] and [3].
///
/// [2] and [3] implement a `struct Quad` which in turn contains a vector of `Quad::corner`. Each
/// `corner` value corresponds to the draft's `struct Quad`.
///
/// [1]: https://datatracker.ietf.org/doc/html/draft-google-cfrg-libzk-00#section-7.6
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [3]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/quad.h
#[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]
pub struct Quad {
    /// The position of ths gate in its layer, corresponding to `gate_number` in the specification.
    pub(crate) gate_index: Size,
    /// Index of the left-hand wire feeding into this gate.
    pub(crate) left_wire_index: Size,
    /// Index of the right-hand wire feeding into this gate.
    pub(crate) right_wire_index: Size,
    /// Index into the circuit's constant table. The value at that index is the quad's value. If the
    /// value is 0, the quad is part of Z. If the value is nonzero, the quad is part of Q. See [1]
    /// for discussion of the combined quad.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    pub(crate) const_table_index: Size,
}

impl Quad {
    /// Encode this quad as deltas relative to the previous quad in the circuit.
    // XXX extend [`crate::Codec`] to take an encoding parameter like prio::codec does so we can
    // pass in prev_quad
    fn encode(&self, prev_quad: Option<Quad>, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        self.gate_index.encode_delta(prev_quad.gate_index, bytes)?;
        self.left_wire_index
            .encode_delta(prev_quad.left_wire_index, bytes)?;
        self.right_wire_index
            .encode_delta(prev_quad.right_wire_index, bytes)?;
        self.const_table_index.encode(bytes)?;

        Ok(())
    }

    /// Encode this quad as deltas relative to the previous quad in the circuit.
    fn decode(prev_quad: Option<Quad>, bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        let gate_index = Size::decode_delta(prev_quad.gate_index, bytes)?;
        let left_wire_index = Size::decode_delta(prev_quad.left_wire_index, bytes)?;
        let right_wire_index = Size::decode_delta(prev_quad.right_wire_index, bytes)?;
        let const_table_index = Size::decode(bytes)?;

        Ok(Self {
            gate_index,
            left_wire_index,
            right_wire_index,
            const_table_index,
        })
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use crate::{
        Codec, Size,
        circuit::{Circuit, Evaluation, Quad},
        fields::{FieldElement, FieldId, fieldp128::FieldP128, fieldp256::FieldP256},
    };
    use ff::Field;
    use serde::Deserialize;
    use std::{
        collections::HashSet,
        fs::File,
        io::{BufReader, Cursor, Read},
    };

    #[test]
    fn roundtrip_quad() {
        let quad = Quad {
            gate_index: Size(1),
            left_wire_index: Size(2),
            right_wire_index: Size(3),
            const_table_index: Size(4),
        };

        let next_quad = Quad {
            gate_index: Size(5),
            left_wire_index: Size(6),
            right_wire_index: Size(7),
            const_table_index: Size(8),
        };

        let mut encoded = Vec::new();
        quad.encode(None, &mut encoded).unwrap();
        let decoded = Quad::decode(None, &mut Cursor::new(&encoded)).unwrap();
        assert_eq!(quad, decoded);

        let mut next_encoded = Vec::new();
        next_quad.encode(Some(quad), &mut next_encoded).unwrap();
        let next_decoded = Quad::decode(Some(quad), &mut Cursor::new(&next_encoded)).unwrap();
        assert_eq!(next_quad, next_decoded);
    }

    /// JSON descriptor of a circuit test vector.
    #[derive(Debug, Clone, Deserialize)]
    pub(crate) struct CircuitTestVector {
        #[allow(dead_code)]
        pub(crate) description: String,
        /// Field used by the circuit.
        pub(crate) field: u8,
        /// Depth of the circuit. This is wire layers, not gate layers.
        pub(crate) depth: u32,
        /// Total quads in the circuit.
        pub(crate) quads: u32,
        /// Not yet clear what this is.
        pub(crate) _terms: u32,
        /// The serialized circuit, decompressed from a file alongside the JSON descriptor.
        #[serde(default)]
        pub(crate) serialized_circuit: Vec<u8>,
    }

    impl CircuitTestVector {
        pub(crate) fn decode(test_vector_name: &'static str) -> (Self, Circuit) {
            let test_vector_path = format!("test-vectors/circuit/{test_vector_name}");

            let mut test_vector: Self = serde_json::from_reader(BufReader::new(
                File::open(format!("{test_vector_path}.json")).unwrap(),
            ))
            .unwrap();

            let mut compressed = Vec::new();
            File::open(format!("{test_vector_path}.circuit.zst"))
                .unwrap()
                .read_to_end(&mut compressed)
                .unwrap();

            test_vector.serialized_circuit = zstd::decode_all(compressed.as_slice()).unwrap();
            let mut cursor = Cursor::new(test_vector.serialized_circuit.as_slice());
            let circuit = Circuit::decode(&mut cursor).unwrap();

            assert_eq!(
                cursor.position() as usize,
                test_vector.serialized_circuit.len(),
                "bytes left over after parsing circuit"
            );

            (test_vector, circuit)
        }
    }

    fn roundtrip_circuit_test_vector<FE: FieldElement>(name: &'static str) {
        let (test_vector, circuit) = CircuitTestVector::decode(name);

        // Verifies that circuits conform to a few invariants that we have interpreted from the
        // specification. Panics if any invariant does not hold for this circuit.
        //
        // It would be nice to do this in `Circuit::decode`, but we need to know which field
        // element is in use.
        assert_eq!(FieldId::try_from(test_vector.field).unwrap(), circuit.field);
        assert_eq!(Size::from(test_vector.depth - 1), circuit.num_layers);
        assert_eq!(test_vector.depth as usize - 1, circuit.layers.len());

        let mut quads_count = 0;
        for (layer_index, layer) in circuit.layers.iter().enumerate() {
            let mut q_quad_gates = HashSet::new();
            let mut z_quad_gates = HashSet::new();

            for (quad_index, quad) in layer.quads.iter().enumerate() {
                assert!(quad.left_wire_index < layer.num_wires);
                assert!(quad.right_wire_index < layer.num_wires);
                assert!(quad.const_table_index < circuit.constant_table.len());

                let next_layer_num_wires = if layer_index == 0 {
                    circuit.num_outputs
                } else {
                    // The Longfellow convention is that layer 0 is outputs and layer num_layers is
                    // inputs, so the next layer of the circuit is -1.
                    // https://datatracker.ietf.org/doc/html/draft-google-cfrg-libzk-01#section-6.3.1
                    circuit.layers[layer_index - 1].num_wires
                };
                if quad.gate_index >= next_layer_num_wires {
                    panic!(
                        "quad {quad_index} on layer {layer_index} has gate number {} exceeding the \
                        number of input wires on the next layer",
                        quad.gate_index
                    );
                }

                // Force parsing of the constants
                let quad_value = circuit.constant::<FE>(quad.const_table_index).unwrap();
                if quad_value.is_zero().into() {
                    z_quad_gates.insert(quad.gate_index);
                } else {
                    q_quad_gates.insert(quad.gate_index);
                }
            }

            // Our interpretation of the specification is that gates should get contributions from
            // either Q or Z but never both.
            let intersection: Vec<_> = q_quad_gates.intersection(&z_quad_gates).collect();
            assert!(intersection.is_empty(), "Q and Z quads intersect");

            quads_count += layer.quads.len();
        }
        assert_eq!(test_vector.quads as usize, quads_count);
        assert_eq!(
            circuit.get_encoded().unwrap(),
            test_vector.serialized_circuit
        );
    }

    #[test]
    fn roundtrip_circuit_longfellow_rfc_1() {
        roundtrip_circuit_test_vector::<FieldP128>(
            "longfellow-rfc-1-87474f308020535e57a778a82394a14106f8be5b",
        );
    }

    #[test]
    fn roundtrip_circuit_test_vector_mac() {
        roundtrip_circuit_test_vector::<FieldP256>(
            "longfellow-mac-circuit-902a955fbb22323123aac5b69bdf3442e6ea6f80-1",
        );
    }

    #[test]
    fn evaluate_circuit_longfellow_rfc_1_true() {
        let (_, circuit) =
            CircuitTestVector::decode("longfellow-rfc-1-87474f308020535e57a778a82394a14106f8be5b");

        // This circuit verifies that 2n = (s-2)m^2 - (s - 4)*m. For example, C(45, 5, 6) = 0.
        let evaluation: Evaluation<FieldP128> = circuit.evaluate(&[45, 5, 6]).unwrap();

        // Output size should match circuit serialization and values should all be zero
        assert_eq!(circuit.num_outputs, evaluation.wires[0].len());
        for output in evaluation.outputs() {
            assert_eq!(*output, FieldP128::ZERO);
        }

        // The remaining wire layers should match wire counts claimed by circuit serialization
        for (circuit_layer, evaluation_layer) in
            circuit.layers.iter().zip(evaluation.wires[1..].iter())
        {
            assert_eq!(circuit_layer.num_wires, evaluation_layer.len());
        }
    }

    #[test]
    fn evaluate_circuit_longfellow_rfc_1_false() {
        let (_, circuit) =
            CircuitTestVector::decode("longfellow-rfc-1-87474f308020535e57a778a82394a14106f8be5b");

        // Evaluate with other values. At least one output element should be nonzero.
        assert!(
            circuit
                .evaluate(&[45, 5, 7])
                .unwrap()
                .outputs()
                .iter()
                .any(|output: &FieldP128| *output != FieldP128::ZERO)
        );
    }
}
